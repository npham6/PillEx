"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
const path = require("path");
const ts = require("typescript");
const config_1 = require("../../config");
class TypescriptCompiler {
    constructor(files, context) {
        this.files = files;
        this.context = context;
    }
    compile(buildDir) {
        return __awaiter(this, void 0, void 0, function* () {
            this.context.logger.debug("compile files count = " + this.files.length);
            const program = ts.createProgram(this.files, this.config(buildDir));
            const emitResult = program.emit();
            const allDiagnostics = ts.getPreEmitDiagnostics(program).concat(emitResult.diagnostics);
            allDiagnostics.forEach(diagnostic => {
                if (!diagnostic.file) {
                    this.context.logger.debug(JSON.stringify(diagnostic, null, 2));
                }
                if (diagnostic.file) {
                    const { line, character } = diagnostic.file.getLineAndCharacterOfPosition(diagnostic.start);
                    const message = ts.flattenDiagnosticMessageText(diagnostic.messageText, '\n');
                    this.context.logger.debug(`${diagnostic.file.fileName} (${line + 1},${character + 1}): ${message}`);
                }
            });
            if (emitResult.emitSkipped) {
                throw new Error('Typescript compilation failed');
            }
            this.context.logger.debug(path.join(config_1.StaticConfig.rootProjectDir, '../node_modules/@types'));
            this.context.logger.debug(path.join(config_1.StaticConfig.rootProjectDir, './node_modules/@types'));
            return emitResult.emittedFiles;
        });
    }
    config(buildDir) {
        return Object.assign({}, baseCompilerOptions, { lib: ['lib.es2017.d.ts'], rootDir: config_1.StaticConfig.rootExecutionDir, outDir: buildDir, typeRoots: [
                path.join(config_1.StaticConfig.rootProjectDir, '../node_modules/@types'),
                path.join(config_1.StaticConfig.rootProjectDir, './node_modules/@types'),
                path.join(config_1.StaticConfig.rootExecutionDir, 'typings'),
                path.join(config_1.StaticConfig.rootExecutionDir, 'node_modules/@types'),
            ] });
    }
}
exports.TypescriptCompiler = TypescriptCompiler;
const baseCompilerOptions = {
    preserveConstEnums: true,
    strictNullChecks: true,
    sourceMap: false,
    target: ts.ScriptTarget.ES5,
    moduleResolution: ts.ModuleResolutionKind.NodeJs,
    lib: ['lib.es2017.d.ts'],
    allowJs: true,
    listEmittedFiles: true,
    skipLibCheck: true,
    allowSyntheticDefaultImports: true
};
//# sourceMappingURL=tsCompiler.js.map