"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const _ = require("lodash");
const fs = require("fs");
const graphql_1 = require("graphql");
const graphql_tools_1 = require("graphql-tools");
const RootSchema_1 = require("../../consts/RootSchema");
class GraphqlController {
    static loadSchema(schemaPaths, predefineSchema = "") {
        return _.reduce(schemaPaths, (res, file) => {
            res += fs.readFileSync(file);
            return res;
        }, predefineSchema);
    }
    /**
     *
     * @param project
     * @return { functionName: "Query/Mutation" }
     */
    static defineGqlFunctionsType(gqlSchema) {
        // bad solution, I think
        // parse graphql file and get function type for all each function
        if (!gqlSchema) {
            return;
        }
        const parsedSchema = graphql_1.parse(gqlSchema);
        return _.transform(parsedSchema.definitions, (res, data) => {
            switch (data.kind) {
                case "ObjectTypeExtension": {
                    const extension = data;
                    const graphqlType = data.name.value;
                    const extendedFieldNames = GraphqlController.processFields(extension.fields);
                    extendedFieldNames.forEach(field => res[field] = graphqlType);
                }
            }
        }, {});
    }
    /**
     *
     * @param project
     */
    static validateSchema(project) {
        // TODO: add mutations and queries
        graphql_tools_1.makeExecutableSchema({
            typeDefs: project.gqlSchema + RootSchema_1.rootGraphqlSchema(),
            resolvers: {
                Mutation: {},
                Query: {}
            }
        });
    }
    /**
     * private functions
     */
    static processFields(fields) {
        return _.transform(fields, (res, f) => {
            res.push(f.name.value);
        }, []);
    }
}
exports.GraphqlController = GraphqlController;
//# sourceMappingURL=graphqlController.js.map