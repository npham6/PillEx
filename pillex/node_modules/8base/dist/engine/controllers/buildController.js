"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
const fs = require("fs-extra");
const projectController_1 = require("./projectController");
const compilers_1 = require("../compilers");
const utils_1 = require("../../common/utils");
/*
  paths:
    /project_dir
      - user's files / folders
      - node_modules
      - .build
        - dist (use for local compile when invoke-local command is invoked
        - meta (use for build meta for project)
        - package (use for package command)
 */
class BuildController {
    /*
      Function workflow
        1. Clean up directory
        2. Create Metadata file
        3. Create Schema file and save it
        4. Archive build and summary
    */
    static package(context) {
        return __awaiter(this, void 0, void 0, function* () {
            BuildController.prepare(context);
            return {
                build: yield BuildController.packageSources(context),
                meta: yield BuildController.packageMetadata(context)
            };
        });
    }
    // compile use only for invoke-local command
    static compile(context) {
        return __awaiter(this, void 0, void 0, function* () {
            BuildController.prepare(context);
            const files = projectController_1.ProjectController.getFunctionSourceCode(context);
            context.logger.debug("resolve compilers");
            const compiler = compilers_1.getCompiler(files, context);
            const compiledFiles = yield compiler.compile(context.config.buildDistPath);
            context.logger.debug("compiled files = " + compiledFiles);
            return {
                compiledFiles
            };
        });
    }
    /**
     * Private functions
     */
    static packageSources(context) {
        const excludedDirectories = [
            context.config.buildDistFolder,
            context.config.packageFolder,
            context.config.metaFolder,
            context.config.buildRootFolder,
            context.config.modulesFolder
        ];
        const sourceToArchive = BuildController.getSourceBuildData(context)
            .filter(dir => !excludedDirectories.includes(dir))
            .map(dir => ({ dist: dir, source: dir }));
        return utils_1.Utils.archiveToMemory(sourceToArchive, context);
    }
    static packageMetadata(context) {
        const metaDir = context.config.metaDir;
        projectController_1.ProjectController.saveMetaDataFile(context.project, metaDir);
        projectController_1.ProjectController.saveSchema(context.project, metaDir);
        projectController_1.ProjectController.saveProject(context.project, metaDir);
        return utils_1.Utils.archiveToMemory([{ source: metaDir }], context);
    }
    static getSourceBuildData(context) {
        return fs.readdirSync(context.config.rootExecutionDir);
    }
    static prepare(context) {
        fs.removeSync(context.config.buildRootDirPath);
        fs.mkdirpSync(context.config.buildDistPath);
        fs.mkdirpSync(context.config.metaDir);
        fs.mkdirpSync(context.config.packageDir);
    }
}
exports.BuildController = BuildController;
//# sourceMappingURL=buildController.js.map