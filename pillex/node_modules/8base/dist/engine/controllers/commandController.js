"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
const utils_1 = require("../../common/utils");
const config_1 = require("../../config");
const path = require("path");
const _ = require("lodash");
const fs = require("fs");
const context_1 = require("../../common/context");
const chalk_1 = require("chalk");
const Colors_1 = require("../../consts/Colors");
class CommandController {
    static instanceCommand(fullPath) {
        try {
            try {
                return utils_1.Utils.undefault(require(require.resolve(fullPath)));
            }
            catch (ex) {
                console.log(ex.message);
            }
        }
        catch (error) {
            throw new Error("Command \"" + path.basename(fullPath) + "\" is invalid");
        }
    }
    static enumerate() {
        return _.transform(fs.readdirSync(config_1.StaticConfig.commandsDir), (commands, file) => {
            const p = path.join(config_1.StaticConfig.commandsDir, file);
            if (fs.statSync(p).isDirectory()) {
                commands.push(this.instanceCommand(p));
            }
        }, []);
    }
}
CommandController.parseError = (error) => {
    if (error.response && error.response.errors && error.response.errors.length > 0 && error.response.errors[0].message) {
        const internalError = error.response.errors[0];
        if (internalError.details) {
            const keys = Object.keys(internalError.details);
            if (keys.length > 0) {
                return internalError.details[keys[0]];
            }
        }
        return internalError.message;
    }
    return error.message;
};
CommandController.wrapHandler = (handler, translations) => {
    return (params) => __awaiter(this, void 0, void 0, function* () {
        const command = params._[0];
        const context = new context_1.Context(params, translations);
        const start = Date.now();
        try {
            yield handler(params, context);
            context.spinner.stop();
            const time = Date.now() - start;
            context.logger.info(`${chalk_1.default.hex(Colors_1.Colors.green)(command)} done. Time: ${chalk_1.default.hex(Colors_1.Colors.green)(time.toLocaleString('en-US'))} ms.`);
        }
        catch (ex) {
            context.spinner.stop();
            const time = Date.now() - start;
            context.logger.error(`${CommandController.parseError(ex)} \n Time: ${chalk_1.default.hex(Colors_1.Colors.red)(time.toLocaleString('en-US'))} ms.`);
        }
    });
};
exports.CommandController = CommandController;
//# sourceMappingURL=commandController.js.map