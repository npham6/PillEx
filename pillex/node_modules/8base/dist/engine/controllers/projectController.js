"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const fs = require("fs");
const path = require("path");
const yaml = require("js-yaml");
const _ = require("lodash");
const config_1 = require("../../config");
const errors_1 = require("../../errors");
const graphqlController_1 = require("../../engine/controllers/graphqlController");
const Extensions_1 = require("../../interfaces/Extensions");
class ProjectController {
    /**
     * public functions
     */
    static initialize(context) {
        const name = path.basename(context.config.rootExecutionDir);
        context.logger.debug("start initialize project \"" + name + "\"");
        context.logger.debug("load main yml file");
        const config = ProjectController.loadConfigFile(context);
        context.logger.debug("load extensions");
        const extensions = ProjectController.loadExtensions(config);
        const gqlSchema = graphqlController_1.GraphqlController.loadSchema(ProjectController.getSchemaPaths(extensions));
        context.logger.debug("load functions count = " + extensions.functions.length);
        context.logger.debug("resolve function graphql types");
        const functionGqlTypes = graphqlController_1.GraphqlController.defineGqlFunctionsType(gqlSchema);
        extensions.resolvers = ResolverUtils.resolveGqlFunctionTypes(extensions.resolvers, functionGqlTypes);
        context.logger.debug("initialize project complete");
        return {
            extensions,
            name,
            gqlSchema,
        };
    }
    static getFunctionSourceCode(context) {
        return _.map(context.project.extensions.functions, f => path.join(context.config.rootExecutionDir, f.pathToFunction));
    }
    static saveSchema(project, outDir) {
        const graphqlFilePath = path.join(outDir, 'schema.graphql');
        fs.writeFileSync(graphqlFilePath, project.gqlSchema);
    }
    static saveProject(project, outDir) {
        const projectObject = {
            name: project.name,
            functions: project.extensions.functions
        };
        const projectFilePath = path.join(outDir, 'project.json');
        return fs.writeFileSync(projectFilePath, JSON.stringify(projectObject, null, 2));
    }
    static saveMetaDataFile(project, outDir) {
        const summaryFile = path.join(outDir, '__summary__functions.json');
        fs.writeFileSync(summaryFile, JSON.stringify({
            functions: project.extensions.functions.map(f => {
                return {
                    name: f.name,
                    handler: f.handler
                };
            }),
            resolvers: project.extensions.resolvers.map(r => {
                return {
                    name: r.name,
                    functionName: r.functionName,
                    gqlType: r.gqlType
                };
            }),
            triggers: project.extensions.triggers,
            webhooks: project.extensions.webhooks
        }, null, 2));
    }
    static getSchemaPaths(extensions) {
        return _.map(extensions.resolvers, f => {
            const p = path.join(config_1.StaticConfig.rootExecutionDir, f.gqlSchemaPath);
            if (!fs.existsSync(p)) {
                throw new Error("schema path \"" + p + "\" not present");
            }
            return p;
        });
    }
    /**
     * private functions
     */
    static loadConfigFile(context) {
        const pathToYmlConfig = config_1.StaticConfig.serviceConfigFileName;
        context.logger.debug("check exist yaml file = " + pathToYmlConfig);
        if (!fs.existsSync(pathToYmlConfig)) {
            throw new Error("Main configuration file \"" + config_1.StaticConfig.serviceConfigFileName + "\" is absent.");
        }
        context.logger.debug("load yaml file");
        try {
            return yaml.safeLoad(fs.readFileSync(pathToYmlConfig, 'utf8'));
        }
        catch (ex) {
            throw new errors_1.InvalidConfiguration(config_1.StaticConfig.serviceConfigFileName, ex.message);
        }
    }
    static loadExtensions(config) {
        return _.reduce(config.functions, (extensions, data, functionName) => {
            FunctionUtils.validateFunctionDefinition(data, functionName);
            extensions.functions.push({
                name: functionName,
                // TODO: create class FunctionDefinition
                handler: functionName + ".handler",
                pathToFunction: FunctionUtils.resolveHandler(functionName, data.handler)
            });
            switch (FunctionUtils.resolveFunctionType(data.type, functionName)) {
                case Extensions_1.ExtensionType.resolver:
                    extensions.resolvers.push({
                        name: functionName,
                        functionName: functionName,
                        gqlSchemaPath: data.schema,
                        gqlType: undefined
                    });
                    break;
                case Extensions_1.ExtensionType.task:
                    extensions.tasks.push({
                        name: functionName,
                        functionName: functionName,
                    });
                    break;
                case Extensions_1.ExtensionType.trigger:
                    if (_.isNil(data.operation)) {
                        throw new errors_1.InvalidConfiguration(config_1.StaticConfig.serviceConfigFileName, "operation field not present in trigger " + functionName);
                    }
                    const operation = data.operation.split("."); // TableName.TriggerType
                    extensions.triggers.push({
                        name: functionName,
                        operation: TriggerUtils.resolveTriggerOperation(operation[1], functionName),
                        tableName: operation[0],
                        functionName,
                        type: TriggerUtils.resolveTriggerType(data.type, functionName)
                    });
                    break;
                case Extensions_1.ExtensionType.webhook:
                    if (!data.method) {
                        throw new errors_1.InvalidConfiguration(config_1.StaticConfig.serviceConfigFileName, "Parameter 'method' is missing in webhook '" + functionName + "'");
                    }
                    extensions.webhooks.push({
                        name: functionName,
                        functionName,
                        httpMethod: data.method,
                        path: data.path ? data.path : functionName
                    });
                    break;
                default:
                    break;
            }
            if (data.schedule) {
                extensions.schedules.push({
                    name: functionName,
                    functionName,
                    scheduleExpression: data.schedule
                });
            }
            return extensions;
        }, {
            resolvers: [],
            tasks: [],
            functions: [],
            webhooks: [],
            triggers: [],
            schedules: []
        });
    }
}
exports.ProjectController = ProjectController;
var ResolverUtils;
(function (ResolverUtils) {
    /**
     * @argument types project, { functionName: type }
     * Function resolve graphql type for each function.
     * we have to know function type (mutation, query) for compile schema on the server side
     */
    function resolveGqlFunctionTypes(resolvers, types) {
        resolvers.forEach(func => {
            const type = types[func.name];
            if (_.isNil(type)) {
                throw new Error("Cannot define graphql type for function \"" + func.name + "\"");
            }
            func.gqlType = type;
        });
        return resolvers;
    }
    ResolverUtils.resolveGqlFunctionTypes = resolveGqlFunctionTypes;
})(ResolverUtils || (ResolverUtils = {}));
var FunctionUtils;
(function (FunctionUtils) {
    function resolveHandler(name, handler) {
        if (_.isString(handler.code)) {
            return handler.code;
        }
        throw new errors_1.InvalidConfiguration(config_1.StaticConfig.serviceConfigFileName, "handler is invalid for function \"" + name + "\"");
    }
    FunctionUtils.resolveHandler = resolveHandler;
    function validateFunctionDefinition(func, name) {
        if (_.isNil(func.handler)) {
            throw new errors_1.InvalidConfiguration(config_1.StaticConfig.serviceConfigFileName, "handler is absent for function \"" + name + "\"");
        }
        if (func.handler.code && !fs.existsSync(path.join(config_1.StaticConfig.rootExecutionDir, func.handler.code))) {
            throw new errors_1.InvalidConfiguration(config_1.StaticConfig.serviceConfigFileName, "unable to determine function \"" + name + "\" source code");
        }
        if (!config_1.StaticConfig.supportedCompileExtension.has(path.extname(func.handler.code))) {
            throw new errors_1.InvalidConfiguration(config_1.StaticConfig.serviceConfigFileName, "function \"" + name + "\" have unsupported file extension");
        }
    }
    FunctionUtils.validateFunctionDefinition = validateFunctionDefinition;
    /**
     *
     * @param type "resolve", "trigger.before", "trigger.after", "subscription", "webhook"
     * @return FunctionType
     */
    function resolveFunctionType(type, functionName) {
        const funcType = type.split(".")[0];
        const resolvedType = Extensions_1.ExtensionType[funcType];
        if (_.isNil(resolvedType)) {
            throw new errors_1.InvalidConfiguration(config_1.StaticConfig.serviceConfigFileName, "Invalid function type " + type + " in function " + functionName);
        }
        return resolvedType;
    }
    FunctionUtils.resolveFunctionType = resolveFunctionType;
})(FunctionUtils || (FunctionUtils = {}));
var TriggerUtils;
(function (TriggerUtils) {
    function resolveTriggerOperation(operation, funcName) {
        const resolvedOperation = Extensions_1.TriggerOperation[operation];
        if (_.isNil(resolvedOperation)) {
            throw new errors_1.InvalidConfiguration(config_1.StaticConfig.serviceConfigFileName, "Invalid trigger operation " + operation + " in function " + funcName);
        }
        return resolvedOperation;
    }
    TriggerUtils.resolveTriggerOperation = resolveTriggerOperation;
    /**
     *
     * @param type "resolve", "trigger.before", "trigger.after", "subscription"
     * @return TriggerStageType
     */
    function resolveTriggerType(type, functionName) {
        const triggerType = type.split(".")[1];
        const resolvedType = Extensions_1.TriggerType[triggerType];
        if (_.isNil(resolvedType)) {
            throw new errors_1.InvalidConfiguration(config_1.StaticConfig.serviceConfigFileName, "Invalid trigger type " + type + " in function " + functionName);
        }
        return resolvedType;
    }
    TriggerUtils.resolveTriggerType = resolveTriggerType;
})(TriggerUtils || (TriggerUtils = {}));
//# sourceMappingURL=projectController.js.map