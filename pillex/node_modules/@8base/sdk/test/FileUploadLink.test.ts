import FileUploadLink, {
  mutateOperationVariables,
  mutateOperationVariablesDeep,
  MAXIMUM_OBJECT_DEEP,
  FILE_FIELD_NAME
} from '../src/FileUploadLink';

import {ApolloLink, execute, FetchResult, NextLink, Observable, Operation} from "apollo-link";
import gql from "graphql-tag";
import {nextTick} from "async";

jest.mock('../src/FileServer');

describe('new file operation link', () => {

  const mockNewFile = () => new File([''], '');

  const mockNewFileInput = () => ({ [FILE_FIELD_NAME]: mockNewFile()} );

  const fileData = (id: string) => <FetchResult> {
    "data": {
      "fileCreate": {
        "id": id,
        "fileId": "auto-generated_uuid",
        "uploadUrl":"someUrl",
        "fields":"{\"policy\":\"ey\"}"
      }
    }
  };

    const query = gql`
      mutation {
        sample {
          id
        }
      }
    `;

  test("no file in query", (done) => {
    expect.assertions(1);
    const fileUploadLink = new FileUploadLink();

    const variables = {
      name: "test"
    };

    const stub: any = jest.fn();

    const link = ApolloLink.from([
      fileUploadLink,
      stub
    ]);

    execute(link, { query, variables }).subscribe({
        next: () => {},
        error: () => fail(),
        complete: () => {
          expect(stub).toHaveBeenCalledTimes(1);
          done();
        }
      }
    );

  });

  test("file in params with additional data", (done) => {
    expect.assertions(4);

    const fileUploadLink = new FileUploadLink();

    const metadata = {
      meta: "data",
      other: "info"
    };

    const variables = {
      name: "test",
      testFile: {
        create: {
          ...mockNewFileInput(),
          public: true,
          meta: metadata
        }
      }
    };

    const fileId = "testId";

    const stubCreateOperation: any = jest.fn().mockReturnValue(
      new Observable(observer => {
        nextTick(() => {
          observer.next(fileData(fileId));
          observer.complete();
        });
      }));

    const link = ApolloLink.from([
      fileUploadLink,
      stubCreateOperation,
    ]);

    execute(link, { query, variables })
      .subscribe(
        () => {},
        () => () => fail(),
        () => {
          const result: any = variables.testFile;
          expect(result.create).toBeUndefined();
          expect(result.connect).toMatchObject({
            id: fileId
          });

          const firstCallParams = stubCreateOperation.mock.calls[0][0];
          expect(firstCallParams.variables.data.meta).toMatchObject(metadata);
          expect(firstCallParams.variables.data.public).toBe(true);

          done();
        },
      );

  });

  test("multiple files in params", (done) => {
    expect.assertions(4);

    const fileUploadLink = new FileUploadLink();

    const fileIds = [
      'file_1',
      'file_2',
      'file_3',
      'file_4'
    ];

    const iterator = new Set(fileIds).values();

    const variables: any = {
      name: "test",
      testFile: {
        create: mockNewFileInput()
      },
      anotherFile: {
        create: mockNewFileInput()
      },
      secondLevel: {
        name: "test1",
        thirdFile: {
          create: mockNewFileInput()
        }
      }
    };

    const stubCreateOperation: any = jest.fn().mockReturnValue(
      new Observable(observer => {
        nextTick(() => {
          observer.next(fileData(iterator.next().value));
          observer.complete();
        });
      }));

    const link = ApolloLink.from([
      fileUploadLink,
      stubCreateOperation
    ]);

    execute(link, {query, variables})
      .subscribe(
        () => {},
        (some) => () => fail(),
        () => {
          expect(stubCreateOperation).toHaveBeenCalledTimes(4);
          expect(variables.testFile.connect.id).toBe(fileIds[0]);
          expect(variables.anotherFile.connect.id).toBe(fileIds[1]);
          expect(variables.secondLevel.thirdFile.connect.id).toBe(fileIds[2]);
          done();
        },
      );

  });

  test("don't upload file to amazon on error", (done) => {
    expect.assertions(3);

    const fileUploadLink = new FileUploadLink();

    const variables: any = {
      name: "test",
      testFile: {
        ...mockNewFileInput(),
      }
    };

    const errorData = {
      "errors": [{
        "some": "Error"
      }],
      "data": null
    };

    const stubCreateOperation: any = jest.fn().mockReturnValue(
      new Observable(observer => {
        nextTick(() => {
          observer.next(errorData);
          observer.complete();
        });
      }));

    const link = ApolloLink.from([
      fileUploadLink,
      stubCreateOperation
    ]);

    execute(link, { query, variables }).subscribe(
      (data) => {
        expect(stubCreateOperation).toHaveBeenCalledTimes(1);
        expect(data.errors).toBeTruthy();
      },
      () => {
        fail();
      },
      () => {
        expect(variables.testFile.fileId).toBeUndefined();
        done();
      },
    );
  });

  test("throw error on next link error", (done) => {
    expect.assertions(1);

    const variables = {
      name: "test"
    };

    const error = 'some error';

    const StubLink = class extends ApolloLink {
      public request(operation: Operation, forward: NextLink) {
        return new Observable(observer => {
          nextTick(() => {
            observer.error(error);
          });
        });
      }
    };

    const link = ApolloLink.from([
      new FileUploadLink(),
      new StubLink(),
    ]);

    execute(link, { query, variables }).subscribe({
        next: () => {},
        error: (err) => {
          expect(err).toBe(error);
          done();
        },
      }
    );
  });

  test('should mutate nested object and replace all files with the result of the handler', () => {
    expect.assertions(1);

    const operationVariables = {
      file1: mockNewFileInput(),
      file2: mockNewFileInput(),
      file3: {
        [FILE_FIELD_NAME]: 'fileInputWithoutFile'
      },
      object: {
        fileArr3: [mockNewFileInput(), 'some-value'],
        fileArr4: [mockNewFileInput(), { file5: mockNewFileInput() }],
        nestedObject: { file6: mockNewFileInput() },
      }
    };

    const file42 = { fileId: 42 };
    const operationVariablesResult = {
      file1: file42,
      file2: file42,
      file3: {
        [FILE_FIELD_NAME]: 'fileInputWithoutFile'
      },
      object: {
        fileArr3: [file42, 'some-value'],
        fileArr4: [file42, { file5: file42 }],
        nestedObject: { file6: file42 },
      }
    };

    const handler42 = (parent: any, obj: Object) => {
      obj["fileId"] = 42;
      delete obj[FILE_FIELD_NAME];
    };

    mutateOperationVariables(operationVariables, handler42);

    expect(operationVariables).toEqual(operationVariablesResult);
  });

  test(`should stop deeping after ${MAXIMUM_OBJECT_DEEP} recursions`, () => {
    const handlerCounter = jest.fn();

    mutateOperationVariablesDeep(null, {}, handlerCounter, MAXIMUM_OBJECT_DEEP + 1);

    expect(handlerCounter.mock.calls.length).toBe(0);
  });
});
