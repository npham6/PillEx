import FileServerNew from '../src/FileServer';
import {Observable} from "apollo-link";
import {nextTick} from "async";

const initialXMLHttpRequest = XMLHttpRequest;

beforeEach(() => {
  // @ts-ignore
  global.XMLHttpRequest = initialXMLHttpRequest;
});

describe('FileServerNew', () => {


  class XMLHttpRequestMock {
    upload = {};
    open = () => {};
    readyState = 4;
    status = 200;
    response = true;
    send = () => {
      nextTick(() => {
        // @ts-ignore
        this.onreadystatechange();
      });
    };
  }

  const addDataWrapper = (response) => ({
    "data": {
      "fileCreate": response
    }
  });

  const responseData = {
    "fileId": "someId",
    "uploadUrl": "someUrl",
    "fields": "{\"policy\":\"ey\"}"
  };

  const file = new File([''], '');

  const createSuccessOperation = (response) => () => new Observable((observer) => {
    observer.next(response);
  });

  const createRejectedOperation = (error) => () => new Observable((observer) => {
    observer.error(error);
  });


  describe('uploadFile', () => {

    it("should add params to request method", async () => {
      const mockOpen = jest.fn();
      const mockSend = jest.fn(function () {
        nextTick(() => {
          this.onreadystatechange();
        });
      });

      class ExtendedXMLHttp extends XMLHttpRequestMock {
        open = mockOpen;
        send = mockSend;
      }

      // @ts-ignore
      global.XMLHttpRequest = ExtendedXMLHttp;


      // @ts-ignore
      await FileServerNew.uploadFile({ file, data: responseData }).then(
        () => {
          expect(mockSend.mock.calls[0][0].get('file')).toBe(file);
          expect(mockOpen).toHaveBeenCalledWith('POST', responseData.uploadUrl, true);
        }
      );
    });

    it("should resolve when correct status", async () => {
      // @ts-ignore
      global.XMLHttpRequest = XMLHttpRequestMock;

      // @ts-ignore
      await FileServerNew.uploadFile({ file, data: responseData }).then(
        (response) => {
          expect(response).toBeTruthy();
        }
      );
    });

    it("should reject when error ready state status",  (done) => {
      class InvalidXMLHttpRequest extends XMLHttpRequestMock {
        status = 66;
      }
      // @ts-ignore
      global.XMLHttpRequest = InvalidXMLHttpRequest;

      // @ts-ignore
      FileServerNew.uploadFile({ file, data: responseData }).catch(
        (err) => {
          expect(err).toBe(66);
          done();
        }
      );
    });

  });

  describe('uploadLink', () => {

    it("should make mutation and get result", async () => {
      // @ts-ignore
      global.XMLHttpRequest = XMLHttpRequestMock;

      const responseData = {
        "fileId": "someId",
        "uploadUrl": "someUrl",
        "fields": "{\"policy\":\"ey\"}"
      };

      const response = addDataWrapper(responseData);

      await FileServerNew.uploadLink({ file, mutate: createSuccessOperation(response) }).then(
        (data) => {
          expect(data).toMatchObject(responseData);
        }
      );
    });

    it("should reject on mutation error",  (done) => {

      const error = 'some error';

      FileServerNew.uploadLink({ file, mutate: createRejectedOperation(error) })
        .catch((err) => {
          expect(err).toBe(error);
          done();
        }
      );
    });

    it("should reject on upload error",  (done) => {
      class InvalidXMLHttpRequest extends XMLHttpRequestMock {
        status = 66;
      }
      // @ts-ignore
      global.XMLHttpRequest = InvalidXMLHttpRequest;

      const response = addDataWrapper(responseData);

      FileServerNew.uploadLink({ file, mutate: createSuccessOperation(response) })
        .catch((err) => {
            expect(err).toBe(66);
            done();
          }
        );
    });

  });


  describe('addEventCallbacks', () => {

    it("should add event callbacks", async () => {
      const request = new XMLHttpRequest();

      const eventCallbacks = {
        onProgress: jest.fn(),
        onLoad: jest.fn(),
        onError: jest.fn(),
        onAbort: jest.fn(),
      };


      FileServerNew.addEventCallbacks(request, eventCallbacks);

      const dispatchEvent = (event) => request.upload.dispatchEvent(event);
      await nextTick(() => {
        dispatchEvent(new ProgressEvent('progress'));
        expect(eventCallbacks.onProgress).toHaveBeenCalled();

        dispatchEvent(new ProgressEvent('load'));
        expect(eventCallbacks.onLoad).toHaveBeenCalled();

        dispatchEvent(new ProgressEvent('error'));
        expect(eventCallbacks.onError).toHaveBeenCalled();

        dispatchEvent(new ProgressEvent('abort'));
        expect(eventCallbacks.onAbort).toHaveBeenCalled();
      });


    });

  });



});
