"use strict";
var __makeTemplateObject = (this && this.__makeTemplateObject) || function (cooked, raw) {
    if (Object.defineProperty) { Object.defineProperty(cooked, "raw", { value: raw }); } else { cooked.raw = raw; }
    return cooked;
};
Object.defineProperty(exports, "__esModule", { value: true });
var errorCodes = require("@8base/error-codes");
var apollo_link_1 = require("apollo-link");
var TokenRefreshLink_1 = require("../src/TokenRefreshLink");
var graphql_tag_1 = require("graphql-tag");
describe("refresh token link", function () {
    var setRefreshTokenInputMock = jest.fn(function () {
        return {
            email: "test-email",
            refreshToken: "refresh-token"
        };
    });
    var authReceived = jest.fn();
    var authFailed = jest.fn();
    var tokenRefreshLink = new TokenRefreshLink_1.default({
        setRefreshTokenInput: setRefreshTokenInputMock,
        authReceived: authReceived,
        authFailed: authFailed,
    });
    var query = graphql_tag_1.default(templateObject_1 || (templateObject_1 = __makeTemplateObject(["\n    mutation {\n      sample {\n        id\n      }\n    }\n  "], ["\n    mutation {\n      sample {\n        id\n      }\n    }\n  "])));
    test("main success scenario", function (done) {
        var stub = jest.fn();
        stub.mockReturnValueOnce(apollo_link_1.Observable.of({
            errors: [{
                    code: errorCodes.TokenExpiredErrorCode
                }],
            data: null
        }));
        stub.mockReturnValueOnce(apollo_link_1.Observable.of({
            data: {
                userRefreshToken: {
                    refreshToken: "new-refresh-token",
                    idToken: "new-id-token"
                }
            }
        }));
        stub.mockReturnValueOnce(apollo_link_1.Observable.of({
            data: {
                success: true
            }
        }));
        var link = apollo_link_1.ApolloLink.from([
            tokenRefreshLink, stub
        ]);
        apollo_link_1.execute(link, { query: query }).subscribe(function () {
        }, function (error) {
            fail();
        }, function () {
            expect(setRefreshTokenInputMock).toHaveBeenCalledTimes(1);
            expect(authReceived).toHaveBeenCalledTimes(1);
            expect(authReceived.mock.calls[0][0].idToken).toBe("new-id-token");
            expect(authReceived.mock.calls[0][0].refreshToken).toBe("new-refresh-token");
            expect(stub).toHaveBeenCalledTimes(3);
            done();
        });
    });
    test("refresh token error", function (done) {
        var stub = jest.fn();
        stub.mockReturnValueOnce(apollo_link_1.Observable.of({
            errors: [{
                    code: errorCodes.TokenExpiredErrorCode
                }],
            data: null
        }));
        stub.mockReturnValueOnce(apollo_link_1.Observable.of({
            errors: [{
                    code: errorCodes.InvalidTokenErrorCode,
                    message: "Invalid Refresh Token"
                }],
            data: {
                userRefreshToken: null
            }
        }));
        var link = apollo_link_1.ApolloLink.from([
            tokenRefreshLink, stub
        ]);
        apollo_link_1.execute(link, { query: query }).subscribe(function () {
            fail();
        }, function (error) {
            expect(stub).toHaveBeenCalledTimes(2);
            done();
        }, function () {
            fail();
        });
        done();
    });
});
var templateObject_1;
//# sourceMappingURL=TokenRefreshLink.test.js.map