"use strict";
var __makeTemplateObject = (this && this.__makeTemplateObject) || function (cooked, raw) {
    if (Object.defineProperty) { Object.defineProperty(cooked, "raw", { value: raw }); } else { cooked.raw = raw; }
    return cooked;
};
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    }
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __assign = (this && this.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
Object.defineProperty(exports, "__esModule", { value: true });
var FileUploadLink_1 = require("../src/FileUploadLink");
var apollo_link_1 = require("apollo-link");
var graphql_tag_1 = require("graphql-tag");
var async_1 = require("async");
jest.mock('../src/FileServer');
describe('new file operation link', function () {
    var mockNewFile = function () { return new File([''], ''); };
    var mockNewFileInput = function () {
        var _a;
        return (_a = {}, _a[FileUploadLink_1.FILE_FIELD_NAME] = mockNewFile(), _a);
    };
    var fileData = function (id) { return ({
        "data": {
            "fileCreate": {
                "id": id,
                "fileId": "auto-generated_uuid",
                "uploadUrl": "someUrl",
                "fields": "{\"policy\":\"ey\"}"
            }
        }
    }); };
    var query = graphql_tag_1.default(templateObject_1 || (templateObject_1 = __makeTemplateObject(["\n      mutation {\n        sample {\n          id\n        }\n      }\n    "], ["\n      mutation {\n        sample {\n          id\n        }\n      }\n    "])));
    test("no file in query", function (done) {
        expect.assertions(1);
        var fileUploadLink = new FileUploadLink_1.default();
        var variables = {
            name: "test"
        };
        var stub = jest.fn();
        var link = apollo_link_1.ApolloLink.from([
            fileUploadLink,
            stub
        ]);
        apollo_link_1.execute(link, { query: query, variables: variables }).subscribe({
            next: function () { },
            error: function () { return fail(); },
            complete: function () {
                expect(stub).toHaveBeenCalledTimes(1);
                done();
            }
        });
    });
    test("file in params with additional data", function (done) {
        expect.assertions(4);
        var fileUploadLink = new FileUploadLink_1.default();
        var metadata = {
            meta: "data",
            other: "info"
        };
        var variables = {
            name: "test",
            testFile: {
                create: __assign({}, mockNewFileInput(), { public: true, meta: metadata })
            }
        };
        var fileId = "testId";
        var stubCreateOperation = jest.fn().mockReturnValue(new apollo_link_1.Observable(function (observer) {
            async_1.nextTick(function () {
                observer.next(fileData(fileId));
                observer.complete();
            });
        }));
        var link = apollo_link_1.ApolloLink.from([
            fileUploadLink,
            stubCreateOperation,
        ]);
        apollo_link_1.execute(link, { query: query, variables: variables })
            .subscribe(function () { }, function () { return function () { return fail(); }; }, function () {
            var result = variables.testFile;
            expect(result.create).toBeUndefined();
            expect(result.connect).toMatchObject({
                id: fileId
            });
            var firstCallParams = stubCreateOperation.mock.calls[0][0];
            expect(firstCallParams.variables.data.meta).toMatchObject(metadata);
            expect(firstCallParams.variables.data.public).toBe(true);
            done();
        });
    });
    test("multiple files in params", function (done) {
        expect.assertions(4);
        var fileUploadLink = new FileUploadLink_1.default();
        var fileIds = [
            'file_1',
            'file_2',
            'file_3',
            'file_4'
        ];
        var iterator = new Set(fileIds).values();
        var variables = {
            name: "test",
            testFile: {
                create: mockNewFileInput()
            },
            anotherFile: {
                create: mockNewFileInput()
            },
            secondLevel: {
                name: "test1",
                thirdFile: {
                    create: mockNewFileInput()
                }
            }
        };
        var stubCreateOperation = jest.fn().mockReturnValue(new apollo_link_1.Observable(function (observer) {
            async_1.nextTick(function () {
                observer.next(fileData(iterator.next().value));
                observer.complete();
            });
        }));
        var link = apollo_link_1.ApolloLink.from([
            fileUploadLink,
            stubCreateOperation
        ]);
        apollo_link_1.execute(link, { query: query, variables: variables })
            .subscribe(function () { }, function (some) { return function () { return fail(); }; }, function () {
            expect(stubCreateOperation).toHaveBeenCalledTimes(4);
            expect(variables.testFile.connect.id).toBe(fileIds[0]);
            expect(variables.anotherFile.connect.id).toBe(fileIds[1]);
            expect(variables.secondLevel.thirdFile.connect.id).toBe(fileIds[2]);
            done();
        });
    });
    test("don't upload file to amazon on error", function (done) {
        expect.assertions(3);
        var fileUploadLink = new FileUploadLink_1.default();
        var variables = {
            name: "test",
            testFile: __assign({}, mockNewFileInput())
        };
        var errorData = {
            "errors": [{
                    "some": "Error"
                }],
            "data": null
        };
        var stubCreateOperation = jest.fn().mockReturnValue(new apollo_link_1.Observable(function (observer) {
            async_1.nextTick(function () {
                observer.next(errorData);
                observer.complete();
            });
        }));
        var link = apollo_link_1.ApolloLink.from([
            fileUploadLink,
            stubCreateOperation
        ]);
        apollo_link_1.execute(link, { query: query, variables: variables }).subscribe(function (data) {
            expect(stubCreateOperation).toHaveBeenCalledTimes(1);
            expect(data.errors).toBeTruthy();
        }, function () {
            fail();
        }, function () {
            expect(variables.testFile.fileId).toBeUndefined();
            done();
        });
    });
    test("throw error on next link error", function (done) {
        expect.assertions(1);
        var variables = {
            name: "test"
        };
        var error = 'some error';
        var StubLink = (function (_super) {
            __extends(class_1, _super);
            function class_1() {
                return _super !== null && _super.apply(this, arguments) || this;
            }
            class_1.prototype.request = function (operation, forward) {
                return new apollo_link_1.Observable(function (observer) {
                    async_1.nextTick(function () {
                        observer.error(error);
                    });
                });
            };
            return class_1;
        }(apollo_link_1.ApolloLink));
        var link = apollo_link_1.ApolloLink.from([
            new FileUploadLink_1.default(),
            new StubLink(),
        ]);
        apollo_link_1.execute(link, { query: query, variables: variables }).subscribe({
            next: function () { },
            error: function (err) {
                expect(err).toBe(error);
                done();
            },
        });
    });
    test('should mutate nested object and replace all files with the result of the handler', function () {
        var _a, _b;
        expect.assertions(1);
        var operationVariables = {
            file1: mockNewFileInput(),
            file2: mockNewFileInput(),
            file3: (_a = {},
                _a[FileUploadLink_1.FILE_FIELD_NAME] = 'fileInputWithoutFile',
                _a),
            object: {
                fileArr3: [mockNewFileInput(), 'some-value'],
                fileArr4: [mockNewFileInput(), { file5: mockNewFileInput() }],
                nestedObject: { file6: mockNewFileInput() },
            }
        };
        var file42 = { fileId: 42 };
        var operationVariablesResult = {
            file1: file42,
            file2: file42,
            file3: (_b = {},
                _b[FileUploadLink_1.FILE_FIELD_NAME] = 'fileInputWithoutFile',
                _b),
            object: {
                fileArr3: [file42, 'some-value'],
                fileArr4: [file42, { file5: file42 }],
                nestedObject: { file6: file42 },
            }
        };
        var handler42 = function (parent, obj) {
            obj["fileId"] = 42;
            delete obj[FileUploadLink_1.FILE_FIELD_NAME];
        };
        FileUploadLink_1.mutateOperationVariables(operationVariables, handler42);
        expect(operationVariables).toEqual(operationVariablesResult);
    });
    test("should stop deeping after " + FileUploadLink_1.MAXIMUM_OBJECT_DEEP + " recursions", function () {
        var handlerCounter = jest.fn();
        FileUploadLink_1.mutateOperationVariablesDeep(null, {}, handlerCounter, FileUploadLink_1.MAXIMUM_OBJECT_DEEP + 1);
        expect(handlerCounter.mock.calls.length).toBe(0);
    });
});
var templateObject_1;
//# sourceMappingURL=FileUploadLink.test.js.map